type Int8 {}
type Int16 {}
type Int32 {}
type Int64 {}
type Int64 {}

type UInt8 {}
type UInt16 {}
type UInt32 {}
type UInt64 {}
type UInt64 {}

vocab kitten {

  intrinsic add_int32 (Int32, Int32 -> Int32)
  intrinsic sub_int32 (Int32, Int32 -> Int32)
  intrinsic mul_int32 (Int32, Int32 -> Int32)
  intrinsic div_int32 (Int32, Int32 -> Int32)
  intrinsic mod_int32 (Int32, Int32 -> Int32)

}

trait + <T> (T, T -> T)

about +:
  operator:
    left 6

instance + (Int32, Int32 -> Int32):
  _::kitten::add_int32

trait - <T> (T, T -> T)

about -:
  operator:
    left 6

instance - (Int32, Int32 -> Int32):
  _::kitten::sub_int32

trait * <T> (T, T -> T)

about *:
  operator:
    left 7

instance * (Int32, Int32 -> Int32):
  _::kitten::mul_int32

trait / <T> (T, T -> T)

about /:
  operator:
    left 7

instance / (Int32, Int32 -> Int32):
  _::kitten::div_int32

trait % <T> (T, T -> T)

about %:
  operator:
    left 7

instance % (Int32, Int32 -> Int32):
  _::kitten::mod_int32

define div_mod<T> (T, T -> T, T):
  -> x, y;
  (x / y) (x % y)

type Char {}

type Float32 {}
type Float64 {}

type Bool:
  case false
  case true

type Optional<T>:
  case none
  case some (T)

type Pair<A, B>:
  case pair (A, B)

define unpair<A, B> (Pair<A, B> -> A, B):
  match: case pair {}

type List<T> {}

vocab kitten {

  intrinsic empty<T> (List<T> -> Bool)
  intrinsic head<T> (List<T> -> Optional<T>)
  intrinsic tail<T> (List<T> -> Optional<List<T>>)
  intrinsic prepend<T> (T, List<T> -> List<T>)

}

define empty<T> (List<T> -> Bool):
  _::kitten::empty

define head<T> (List<T> -> Optional<T>):
  _::kitten::head

define tail<T> (List<T> -> Optional<List<T>>):
  _::kitten::tail

define prepend<T> (T, List<T> -> List<T>):
  _::kitten::prepend

define head_tail<T> (List<T> -> Optional<Pair<T, List<T>>>):
  -> xs;
  match (xs head):
    case none:
      none
    case some -> y:
      match (xs tail):
        case none:
          none
        case some -> ys:
          y ys pair some

define map<A, B, +P> (List<A>, (A -> B +P) -> List<B> +P):
  -> xs, f;
  match (xs head_tail):
    case none:
      []
    case some:
      unpair -> y, ys;
      y f call -> z;
      ys f map -> zs;
      z zs prepend

vocab kitten {

  intrinsic print (List<Char> -> +IO)

}

trait print<T> (T -> +_::IO)

instance print (List<Char> -> +IO):
  _::kitten::print

trait show<T> (T -> _::List<_::Char>)

instance show (List<Char> -> List<Char>) {}

instance show (Char -> List<Char>):
  -> x;
  [x]

define say<T> (T -> +IO):
  show print
  "\n" print

permission Fail<R..., S..., +P> (R..., (R... -> S... +Fail +P) -> S... +P):
  with (+Fail)

permission IO<R..., S..., +P> (R..., (R... -> S... +IO +P) -> S... +P):
  with (+IO)

define drop<T> (T ->):
  -> _;

define dup<T> (T -> T, T):
  -> x;
  x x
