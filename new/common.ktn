type Int8 {}
type Int16 {}
type Int32 {}
type Int64 {}
type Int64 {}

type UInt8 {}
type UInt16 {}
type UInt32 {}
type UInt64 {}
type UInt64 {}

vocab kitten {

  intrinsic add_int32 (Int32, Int32 -> Int32)
  intrinsic sub_int32 (Int32, Int32 -> Int32)
  intrinsic mul_int32 (Int32, Int32 -> Int32)
  intrinsic div_int32 (Int32, Int32 -> Int32)
  intrinsic mod_int32 (Int32, Int32 -> Int32)
  intrinsic lt_int32 (Int32, Int32 -> Bool)
  intrinsic gt_int32 (Int32, Int32 -> Bool)
  intrinsic le_int32 (Int32, Int32 -> Bool)
  intrinsic ge_int32 (Int32, Int32 -> Bool)
  intrinsic eq_int32 (Int32, Int32 -> Bool)
  intrinsic ne_int32 (Int32, Int32 -> Bool)
  intrinsic add_float64 (Float64, Float64 -> Float64)
  intrinsic sub_float64 (Float64, Float64 -> Float64)
  intrinsic mul_float64 (Float64, Float64 -> Float64)
  intrinsic div_float64 (Float64, Float64 -> Float64)
  intrinsic mod_float64 (Float64, Float64 -> Float64)
  intrinsic lt_float64 (Float64, Float64 -> Bool)
  intrinsic gt_float64 (Float64, Float64 -> Bool)
  intrinsic le_float64 (Float64, Float64 -> Bool)
  intrinsic ge_float64 (Float64, Float64 -> Bool)
  intrinsic eq_float64 (Float64, Float64 -> Bool)
  intrinsic ne_float64 (Float64, Float64 -> Bool)

}

trait + <T> (T, T -> T)

about +:
  operator:
    left 6

instance + (Int32, Int32 -> Int32):
  _::kitten::add_int32

instance + (Float64, Float64 -> Float64):
  _::kitten::add_float64

trait - <T> (T, T -> T)

about -:
  operator:
    left 6

instance - (Int32, Int32 -> Int32):
  _::kitten::sub_int32

instance - (Float64, Float64 -> Float64):
  _::kitten::sub_float64

trait * <T> (T, T -> T)

about *:
  operator:
    left 7

instance * (Int32, Int32 -> Int32):
  _::kitten::mul_int32

instance * (Float64, Float64 -> Float64):
  _::kitten::mul_float64

trait / <T> (T, T -> T)

about /:
  operator:
    left 7

instance / (Int32, Int32 -> Int32):
  _::kitten::div_int32

instance / (Float64, Float64 -> Float64):
  _::kitten::div_float64

trait % <T> (T, T -> T)

about %:
  operator:
    left 7

instance % (Int32, Int32 -> Int32):
  _::kitten::mod_int32

instance % (Float64, Float64 -> Float64):
  _::kitten::mod_float64

define div_mod<T> (T, T -> T, T):
  -> x, y;
  (x / y) (x % y)

trait < <T> (T, T -> Bool)

about <:
  operator:
    4

trait > <T> (T, T -> Bool)

about >:
  operator:
    4

trait <= <T> (T, T -> Bool)

about <=:
  operator:
    4

trait >= <T> (T, T -> Bool)

about >=:
  operator:
    4

trait = <T> (T, T -> Bool)

about =:
  operator:
    4

trait <> <T> (T, T -> Bool)

about <>:
  operator:
    4

instance < (Int32, Int32 -> Bool):
  _::kitten::lt_int32

instance > (Int32, Int32 -> Bool):
  _::kitten::gt_int32

instance <= (Int32, Int32 -> Bool):
  _::kitten::le_int32

instance >= (Int32, Int32 -> Bool):
  _::kitten::ge_int32

instance = (Int32, Int32 -> Bool):
  _::kitten::eq_int32

instance <> (Int32, Int32 -> Bool):
  _::kitten::ne_int32

instance < (Float64, Float64 -> Bool):
  _::kitten::lt_float64

instance > (Float64, Float64 -> Bool):
  _::kitten::gt_float64

instance <= (Float64, Float64 -> Bool):
  _::kitten::le_float64

instance >= (Float64, Float64 -> Bool):
  _::kitten::ge_float64

instance = (Float64, Float64 -> Bool):
  _::kitten::eq_float64

instance <> (Float64, Float64 -> Bool):
  _::kitten::ne_float64

type Char {}

type Float32 {}
type Float64 {}

type Bool:
  case false
  case true

define not (Bool -> Bool):
  if:
    false
  else:
    true

// Strict intersection.
trait & <T> (T, T -> T)

about &:
  operator:
    right 3

instance & (Bool, Bool -> Bool):
  -> x, y;
  if (x):
    y
  else:
    false

// Lazy intersection.
trait && <T> (T, (-> T) -> T)

instance && (Bool, (-> Bool) -> Bool):
  -> x, y;
  if (x):
    y call
  else:
    false

// Strict union.
trait | <T> (T, T -> T)

about |:
  operator:
    right 2

instance | (Bool, Bool -> Bool):
  -> x, y;
  if (x):
    true
  else:
    y

// Lazy union.
trait || <T> (T, (-> T) -> T)

about ||:
  operator:
    right 2

instance || (Bool, (-> Bool) -> Bool):
  -> x, y;
  if (x):
    true
  else:
    y call

// Strict difference.
trait ~ <A> (A, A -> A)

about ~:
  operator:
    5

instance ~ (Bool, Bool -> Bool):
  swap
  if { not }

// Strict implication.
define --> (Bool, Bool -> Bool):
  -> a, b;
  if (a) { b } else { true }

about -->:
  operator:
    right 1

// Lazy implication.
define ---> (Bool, (-> Bool) -> Bool):
  -> a, b;
  if (a) { b call } else { true }

about --->:
  operator:
    right 1

type Optional<T>:
  case none
  case some (T)

type Pair<A, B>:
  case pair (A, B)

define unpair<A, B> (Pair<A, B> -> A, B):
  match: case pair {}

type List<T> {}

vocab kitten {

  intrinsic empty<T> (List<T> -> Bool)
  intrinsic head<T> (List<T> -> Optional<T>)
  intrinsic tail<T> (List<T> -> Optional<List<T>>)
  intrinsic prepend<T> (T, List<T> -> List<T>)

}

define empty<T> (List<T> -> Bool):
  _::kitten::empty

// TODO: Use Size, not Int32.
define length<T> (List<T> -> Int32):
  match (tail):
    case none:
      0
    case some:
      length (+ 1)

define head<T> (List<T> -> Optional<T>):
  _::kitten::head

define tail<T> (List<T> -> Optional<List<T>>):
  _::kitten::tail

define prepend<T> (T, List<T> -> List<T>):
  _::kitten::prepend

define head_tail<T> (List<T> -> Optional<Pair<T, List<T>>>):
  -> xs;
  match (xs head):
    case none:
      none
    case some -> y:
      match (xs tail):
        case none:
          none
        case some -> ys:
          y ys pair some

define map<A, B, +P> (List<A>, (A -> B +P) -> List<B> +P):
  -> xs, f;
  match (xs head_tail):
    case none:
      []
    case some:
      unpair -> y, ys;
      y f call -> z;
      ys f map -> zs;
      z zs prepend

vocab kitten {

  intrinsic print (List<Char> -> +IO)

}

trait print<T> (T -> +IO)

instance print (List<Char> -> +IO):
  _::kitten::print

trait show<T> (T -> List<Char>)

instance show (List<Char> -> List<Char>) {}

instance show (Char -> List<Char>):
  -> x;
  [x]

instance show (Bool -> List<Char>):
  if { "true" } else { "false" }

define say<T> (T -> +IO):
  show print
  "\n" print

permission Fail<R..., S..., +P> (R..., (R... -> S... +Fail +P) -> S... +P):
  with (+Fail)

vocab kitten {

  intrinsic abort (List<Char> -> +Fail)

}

define abort (-> +Fail):
  "abort called" _::kitten::abort

define assert (List<Char>, (-> Bool) -> +Fail):
  -> message, test;
  if (test call not):
    message _::kitten::abort

permission IO<R..., S..., +P> (R..., (R... -> S... +IO +P) -> S... +P):
  with (+IO)

define drop<T> (T ->):
  -> _;

define dup<T> (T -> T, T):
  -> x;
  x x

define swap<A, B> (A, B -> B, A):
  -> x, y;
  y x
